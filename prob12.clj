;; The sequence of triangle numbers is generated by adding the natural
;; numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6
;; + 7 = 28. The first ten terms would be:

;; 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

;; Let us list the factors of the first seven triangle numbers:

;;      1: 1 3: 1,3 6: 1,2,3,6 10: 1,2,5,10 15: 1,3,5,15 21: 1,3,7,21
;;      28: 1,2,4,7,14,28

;; We can see that 28 is the first triangle number to have over five
;; divisors.

;; What is the value of the first triangle number to have over five
;; hundred divisors?


(defn triangle-numbers []
  (let [lazy-tri (fn lazy-tri [n sum]
                       (cons (+ n sum)
                             (lazy-seq (lazy-tri (inc n) (+ n sum)))))]
    (lazy-tri 1 0)))

(defn prob12 []
  ;; naive brute force approach, takes too long
  (let [get-factors (fn lazy-fact [num i j]
                      (if (<= j i)
                        nil
                        (if (zero? (rem num i))
                          (concat (distinct [i (/ num i)]) (lazy-seq (lazy-fact num (inc i) (/ num i))))
                          (lazy-seq (lazy-fact num (inc i) j)))))]

    (loop [tri-seq (triangle-numbers)]
      (let [trinum (first tri-seq)]
        ;; (println trinum )
        (if (> (count (get-factors trinum 1 trinum)) 500)
          trinum
          (recur (next tri-seq)))))))

(defn is-prime? [num]
  ;; primality test by trail-division
  (cond (< num 2) false
        (= num 2) true
        (even? num) false
        :else (loop [n 3]
                (cond (> (* n n) num) true
                      (zero? (rem num n)) false
                      :else (recur (+ 2 n))))))

(defn prime-sequence []
  ;; generate lazy seq of primes
  (let [next-primes (fn lazy-primes [num]
                      ;; return lazy prime primes starting from num
                      (if (is-prime? num)
                        (cons num (lazy-seq (lazy-primes (inc num))))
                        (lazy-seq (lazy-primes (inc num)))))]
    (next-primes 2)))

(defn prime-factors [number]
  ;; prime-factors by trial divison
  (loop [num number
         prime-seq (prime-sequence)
         factors nil]

    (let [prime-num (first prime-seq)]
      (cond (> (* prime-num prime-num) num) (cons num factors)
            (zero? (rem num prime-num)) (recur (/ num prime-num )
                                               (prime-sequence)
                                               (cons prime-num factors))
            :else (recur num (next prime-seq) factors)))))

(defn count-item [coll item]
  (count (filter #(= item %) coll)))

(defn prime-factors-by-power [num]
  ;; return a map with prime as keys
  ;; and count (power) as values
  (let [factors (prime-factors num)]
    (into {} (for [itm (distinct factors)
                   :let [cnt (count-item factors itm)]]
               {itm cnt}))))

(defn get-factors-count [n]
  ;; from http://www.wikihow.com/Find-How-Many-Factors-Are-in-a-Number
  (apply * (map (fn [[prime pow]] (inc pow))
                (seq (prime-factors-by-power n)))))

(defn prob12-alt []
  ;; faster implementation using prime factorization to find
  ;; number of primes
  (loop [tri-seq (triangle-numbers)]
      (let [trinum (first tri-seq)]
        (if (> (get-factors-count trinum) 500)
          trinum
          (recur (next tri-seq))))))
